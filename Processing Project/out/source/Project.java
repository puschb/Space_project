/* autogenerated by Processing revision 1279 on 2023-03-08 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.*;
import java.util.regex.*;
import peasy.*;
import java.net.*;
import processing.sound.*;
import java.awt.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Project extends PApplet {

//Main







HomeScreen homeScreen;
CountriesScreen countriesScreen;
AltitudeScreen altitudeScreen;
GlobeScreen globeScreen;
TimeScreen timeScreen;
GraphScreen graphScreen;
Screen currentScreen;
AIScreen aiScreen;
Table gcat;
Table orgs;
Table activeSatellites;
float currentWidth, currentHeight;
PImage sunIm, jupiterIm, earthIm, marsIm, mercuryIm, neptuneIm, saturnIm, uranusIm, venusIm, infographic;
PeasyCam cam;
SoundFile audio;

 public void setup()
{
    /* size commented out by preprocessor */;
    /* smooth commented out by preprocessor */;
    surface.setResizable(true);
    background(234,152,200);
    currentWidth = width;
    currentHeight = height;
    //create table for each data set
    gcat = loadTable("Data/gcat.tsv", "header, tsv");
    orgs = loadTable("Data/orgs.tsv", "header, tsv");
    activeSatellites = loadTable("Data/active-satellites.tsv", "header, tsv");
    //create font
    PFont myFont = createFont("Georgia", 100, true);
    textFont(myFont);
    //add planet images
    sunIm =  loadImage("Images/sun.jpeg");
    earthIm = loadImage("Images/earthmap1k.jpg");
    jupiterIm = loadImage("Images/jupitermap.jpg");
    marsIm = loadImage("Images/mars_1k_color.jpg");
    mercuryIm = loadImage("Images/mercurymap.jpg");
    neptuneIm = loadImage("Images/neptunemap.jpg");
    saturnIm = loadImage("Images/saturnmap.jpg");
    uranusIm = loadImage("Images/uranusmap.jpg");
    venusIm = loadImage("Images/venusmap.jpg");
    infographic = loadImage("Images/Infographic.png");
    //camera for 3D images
    cam = new PeasyCam(this,width/2,height/2,0,600);
    //cam.setMinimumDistance(600);
    cam.setMaximumDistance(7000);    
    cam.setActive(false);
    //screen objects
    homeScreen = new HomeScreen();
    countriesScreen = new CountriesScreen();
    altitudeScreen = new AltitudeScreen();
    globeScreen = new GlobeScreen();
    timeScreen = new TimeScreen();
    graphScreen = new GraphScreen();
    aiScreen = new AIScreen();
    currentScreen = homeScreen;
    //audio in background
    audio = new SoundFile(this, "InterstellarJourney.wav");
    audio.loop();
}

//funtion to resize each screen
//resize all screens --> update this when a new screen is added
 public void resize()
{
    cam = new PeasyCam(this,width/2,height/2,0,600);
    cam.setMaximumDistance(7000);
    System.gc();
    cam.reset();
    currentWidth = width;
    currentHeight = height;
    homeScreen.resize();
    globeScreen.resize();
    altitudeScreen.resize();
    countriesScreen.resize();
    timeScreen.resize();
    graphScreen.resize();
    aiScreen.resize();
}

 public void draw()
{
    cam.beginHUD();
    if(currentWidth != width || currentHeight != height)
    {
        noLoop();
        background(currentScreen.screenColour);
        resize();
        loop();
    }
    else
    {
        currentScreen.draw();
    }
    cam.endHUD();
}

 public void mouseMoved(MouseEvent e)
{
    currentScreen.getEvent(e);
}

//function to switch screens when mouse is released
 public void mouseReleased(MouseEvent e) 
{
  switch(currentScreen.getEvent(e))
  {
    case HOME_SCREEN:
        cam.setActive(false);
        cam.reset();
        currentScreen = homeScreen;
        break;
    case COUNTRY_SCREEN:
        cam.setActive(false);
        currentScreen = countriesScreen;
        break;
    case ALTITUDE_SCREEN:
        cam.setActive(false);
        currentScreen = altitudeScreen; 
        break;
    case GLOBE_SCREEN:
        cam.setActive(true);
        cam.reset();
        currentScreen = globeScreen; 
        break;
    case TIME_SCREEN:
        cam.setActive(false);
        currentScreen = timeScreen;
        break;
    case GRAPH_SCREEN:
        cam.setActive(false);
        cam.reset();
        currentScreen = graphScreen;
        break;
    case AI_SCREEN:
        cam.setActive(false);
        cam.reset();
        currentScreen = aiScreen;
        break;
    
  }
}

 public void mouseDragged(MouseEvent e)
{
    currentScreen.getEvent(e);
}

 public void keyPressed(KeyEvent e) 
{
    currentScreen.getEvent(e);
}







//class created by B. Pusch
//screen that has the link to the AI model we created
public class AIScreen extends Screen 
{
    private static final int AI_LINK_BUTTON = 11;
    private float fHeaderHeight, headerHeight;
    private static final String LINK_TO_AI = "https://colab.research.google.com/drive/1lvM66PfdMTXnljwyzCn9JMUZ_Rh8vAPv?usp=sharing";
    ArrayList<Star> stars;
    private String title, instruction1, instruction2, instruction3,instruction4, example;
    public AIScreen()
    {
        stars = new ArrayList<Star>();
        this.screenColour = color(0);
        this.title = "Instructions";
        this.instruction1 = "1. Click and collapse 'Use AI Model to Query'.";
        this.instruction2 = "2. Press on play button on left hand side under 'Use AI Model to Query'. (Press RUN ANYWAYS)";
        this.instruction3 = "3. Click into 'Use AI Model to Query'.";
        this.instruction4 = "4. Click into question box and ask any question related to the data!";
        this.example = "For example, 'When was the Kosmos rocket launched?'.";
        this.fHeaderHeight = .05f;
        headerHeight = height*fHeaderHeight;
        screenWidgets.add(new ButtonWidget(4/12.0f,5.5f/12,4/12.0f,1/12.0f, "Visit our AI",AI_LINK_BUTTON));
        screenWidgets.add(new ButtonWidget(.01f,.01f,(fHeaderHeight-.01f)*2, fHeaderHeight-.02f,"Return",HOME_SCREEN));
        for(int i = 0;i<500;i++)
            stars.add(new Star());
    }
    //draw function created by B.Pushc
    public void draw()
    {
        pushStyle();
        background(this.screenColour);
        //draw divider
        fill(50);
        strokeWeight(2);
        stroke(200);
        rect(width*0.05f,height*.6f, .9f*width, .3f*height,8);
        //draw stars
        pushMatrix();
        translate(width/2,height/3);
        for (Star s:stars)
        {
            s.update();
            s.drawStars();
        }
        popMatrix();
        super.draw();
        //draw instructions
        fill(255);
        textAlign(CENTER,TOP);
        textSize(30);
        text(this.title,width*0.5f,height*0.6f);
        textSize(20);
        text(this.instruction1, width*0.5f,height*0.65f);
        text(this.instruction2, width*0.5f,height*0.7f);
        text(this.instruction3, width*0.5f,height*0.75f);
        text(this.instruction4, width*0.5f, height*0.8f);
        text(this.example, width*0.5f,height*0.85f);
        popStyle();

    }

    //event function created by B.Pushc
    public int getEvent(MouseEvent e)
    {
        int event;
        for(Widget w: screenWidgets)
        {
            event = w.getEvent(e);
            switch(event)
            {
                case HOME_SCREEN:
                    return event;
                case AI_LINK_BUTTON:
                    try {
	                        Desktop.getDesktop().browse(new URL(LINK_TO_AI).toURI());
	                    } 
                    catch (Exception error) {
	                    System.out.println(error);
	                }
                    return event;
            }
        }
        return NULL_EVENT;

    }

    //resize function created by B.Pushc
     public void resize()
    {
        super.resize();
        this.headerHeight = fHeaderHeight*height;
    }
}
//Class created by L. Chow
//Screen for altitude query by objects within a certain altitude (perigee/apogee) range displayed though a bar chart
public class AltitudeScreen extends Screen 
{ 
    private float fHeaderHeight, fVisualizationDivider, headerHeight, visualizationDivider,maxRange, minRange;
    private String title, xLabel, yLabel, switchEvent;
    private int barColor;
    private ArrayList<Mapping> data;
    private static final int switchPerigeeEvent = 11;
    private static final int switchApogeeEvent = 12;
    private static final int updateButtonEvent = 13;
    private static final int minInputEvent = 14;
    private static final int maxInputEvent = 15;

    public AltitudeScreen()
    {
        super();
        this.screenColour = color(0);
        this.fHeaderHeight = .05f;
        this.fVisualizationDivider = .75f;
        this.headerHeight = height*fHeaderHeight;
        this.visualizationDivider = width*fVisualizationDivider;
        this.title = "Perigee Bar Chart";
        this.xLabel = "Type of Object";
        this.yLabel = "Total Objects";
        this.switchEvent = "Perigee";
        this.maxRange = 400; 
        this.minRange = -100; 
        this.data = new ArrayList<Mapping>();
        getValues();
        // add bar chart to screen
        screenGraphs.add(new BarChart(0.0f,fHeaderHeight,fVisualizationDivider, 1-fHeaderHeight, this.title, this.xLabel, this.yLabel, this.data));
        // add widgets to the screen
        screenWidgets.add(new ButtonWidget(.01f,.01f,(fHeaderHeight-.01f)*2, fHeaderHeight-.02f,"Return",GRAPH_SCREEN)); 
        screenWidgets.add(new ButtonWidget(.775f, .125f, .15f, .15f, "Perigee",switchPerigeeEvent));
        screenWidgets.add(new ButtonWidget(.775f, .3f, .15f, .15f, "Apogee",switchApogeeEvent)); 
        screenWidgets.add(new ButtonWidget(.75f,.775f,.2f,.075f,"Update Graph", updateButtonEvent));
        // add maximum and minimum text boxes to the screen
        screenWidgets.add(new TextBox(.75f,.525f,.2f,.05f,minInputEvent,"Numbers"));
        screenWidgets.add(new TextBox(.75f,.66f,.2f,.05f,maxInputEvent,"Numbers"));
    }

    
    public void draw()
    {
        pushStyle();
        background(this.screenColour);
        //draw header
        fill(color(32,33,36));
        rect(0,0,width,headerHeight);
        //draw divider
        fill(50);
        strokeWeight(2);
        stroke(200);
        rect(width*.725f,height*.1f, .25f*width, .8f*height,8);
        fill(255);
        textSize(20*height/800);
        text("Minimum",width*.85f,height*.5f);
        text("Maximum",width*.85f,height*.65f);
        popStyle();
        super.draw();
    }

    
    public int getEvent(MouseEvent e)
    {
        int event;
        for (Widget w: screenWidgets)
        {
            event = w.getEvent(e);
            switch(event)
            {
                // if perigee widget is pressed, it will get the new values and create a new graph
                case switchPerigeeEvent:
                    this.switchEvent = "Perigee";
                    getValues();
                    ((BarChart)screenGraphs.get(0)).setGraph(this.data,"Perigee Bar Chart",this.xLabel,this.yLabel); 
                    return event;
                // if apogee widget is pressed, it will get the new values and create a new graph
                case switchApogeeEvent:
                    this.switchEvent = "Apogee";
                    getValues();
                    ((BarChart)screenGraphs.get(0)).setGraph(this.data,"Apogee Bar Chart",this.xLabel,this.yLabel);
                    return event;
                case minInputEvent:
                    return event;
                case maxInputEvent:
                    return event;
                // if update button is pressed, it will get new values between the new range for perigee and create a new graph
                case updateButtonEvent:
                    this.switchEvent = "Perigee";
                    setPerigee(this.maxRange,this.minRange);
                    getValues();
                    ((BarChart)screenGraphs.get(0)).setGraph(this.data,"Perigee Bar Chart",this.xLabel,this.yLabel); 
                    return event;
                case GRAPH_SCREEN:
                    return event;
            }
        }
        return NULL_EVENT;
    }
    
     public int getEvent(KeyEvent e)
   {
       int event;
       for(Widget w: screenWidgets)
       {
           event = w.getEvent(e);
           switch(event)
           {
               // turns string input to float for maximum and minimum
               case minInputEvent:
                    try{this.minRange = Float.parseFloat(((TextBox)w).getString());}
                    catch(Exception e1) {return event;}
                    return event;
               case maxInputEvent:
                    try{this.maxRange = Float.parseFloat(((TextBox)w).getString());}
                    catch(Exception e1){return event;}
                    return event;
           }
       }
       return NULL_EVENT;
   }

    // function to get values from data set and put them into an arraylist to use in the barchart
    private void getValues()
    {
        boolean hasData = true;
       for (int row = 0; row <= gcat.getRowCount(); row++) 
       {
           try
           {
            String value = gcat.getString(row, this.switchEvent);
            Float num = Float. parseFloat(value);
            if (num>=this.minRange && num <=this.maxRange)
            {
                if (hasData && this.data != null)
                    this.data.clear();
                hasData = false;
                //Just quering objects that are P, R, C, D
                String type = Character.toString(gcat.getString(row, "Type").replaceAll("[^PRCD]", "").charAt(0));
                switch (type)
                {
                    case ("P"):
                    type = "Payload";
                    break;
                    case("R"):
                    type = "Vehicle";
                    break;
                    case("C"):
                    type = "Component";
                    break;
                    case("D"):
                    type = ("Debris");
                    break;
                }
                Mapping category = new Mapping(type);
                if(category != null && !data.contains(category))
                    data.add(category);
                else if(data.contains(category))
                    this.data.get(this.data.indexOf(category)).increment();
            }
           }
           catch (Exception e){

           }
       }
    }

    // resize screen
     public void resize()
   {
       super.resize();
       this.visualizationDivider = fVisualizationDivider*width;
       this.headerHeight = fHeaderHeight*height;
   }

    // function to ensure perigee entered is within bounds
   private void setPerigee(float maxRange, float minRange){
       if (maxRange<MINIMUM_PERIGEE)
            maxRange = MINIMUM_PERIGEE;
        if (maxRange>MAXMIM_PERIGEE)
            maxRange = MAXMIM_PERIGEE;
   }

    // function to ensure apogee entered is within bounds
   private void setApogee (float maxRange, float minRange){
       if (maxRange<MINIMUM_APOGEE)
            maxRange = MINIMUM_PERIGEE;
        if (maxRange>MAXMIM_PERIGEE)
            maxRange = MAXIMUM_APOGEE;
   }
}
//Class created by G. Mullen 
//Modified by B. Pusch to incorporate more functionality
//Object for a bar chart object
public class BarChart extends Graph
{   
    ArrayList<Mapping> data;
    String xALabel, yALabel;
    ArrayList<Integer> barColors;


    public BarChart(float fx, float fy, float fwidth, float fheight,String title, String xALabel, String yALabel, ArrayList<Mapping> data)
    {
        super(fx,fy,fwidth,fheight,title);
        this.xALabel = xALabel; this.yALabel = yALabel;
        this.data = data;
        this.barColors = new ArrayList<Integer>();
        createBarColors();
    }

    public void draw()
    {
        pushStyle();
        //calculating offset
        float leftOffsetX = this.gWidth*.1f;
        float rightOffsetX = this.gWidth *.2f;
        float offsetY = this.gHeight*.1f;
        //display title
        fill(255);
        textSize(getTextSizeChart(gWidth,offsetY,this.title.length()));
        textAlign(CENTER,TOP);
        text(this.title,this.gWidth/2+this.x,this.y);
        //draw axes and dots
        drawAxes(leftOffsetX, rightOffsetX, offsetY);
        drawColumnsWithLabels(leftOffsetX, rightOffsetX, offsetY);
        popStyle();
    }

    //function to draw axes and x and y axis labels created by B.Pusch
    private void drawAxes(float leftOffset, float rightOffset, float offsetY)
    {
        pushStyle();
        strokeWeight(1);
        stroke(255);
        line(this.x+leftOffset,this.y+offsetY,this.x+leftOffset,this.y+this.gHeight-offsetY);
        line(this.x+leftOffset,this.y+this.gHeight-offsetY,this.x+this.gWidth-rightOffset,this.y+this.gHeight-offsetY);
        drawHashMarks(leftOffset, offsetY);
        fill(255);
        textAlign(CENTER, BOTTOM);
        textSize(20 *height/800);
        text(this.yALabel,this.x+leftOffset,this.y+offsetY-20*height/800);
        textAlign(LEFT,BOTTOM);
        textSize(15* width/1000);
        text(this.xALabel, this.x+this.gWidth-rightOffset,this.y+this.gHeight-offsetY);
        popStyle();
    }

    //function called in drawAxes() to draw the lines and caluculate the values of the y axis  created by B.Pusch
    private void drawHashMarks(float leftOffset, float offsetY)
    {
        pushStyle();
        float maxValue = Collections.max(this.data, new MappingComparator()).getValue();
        float axisLength = this.gHeight*.8f;
        stroke(255);
        fill(255);
        textAlign(RIGHT,CENTER);
        for(int i = 1;i<=5;i++)
            {
                float hashHeight = this.y+this.gHeight-offsetY-axisLength/5*i;
                line(this.x+leftOffset,hashHeight,this.x+leftOffset+10, hashHeight);
                String hashLabel = Integer.toString((int)(maxValue/5.0f*i)) + " ";
                textSize(getTextSizeChart(leftOffset,axisLength/10,hashLabel.length()));
                text(hashLabel,this.x+leftOffset,hashHeight);
            } 
        popStyle();
    } 

    //function to draw the columns and place the label under each bar created by B.Pusch
    private void drawColumnsWithLabels(float leftOffsetX, float rightOffsetX, float offsetY)
    {
        pushStyle();
        float maxValue = Collections.max(this.data, new MappingComparator()).getValue();
        float axisLength = this.gWidth*.7f;
        float axisYLength = this.gHeight*.8f;
        float increment = axisLength/data.size();
        float columnPosition = this.x+leftOffsetX+ axisLength/(this.data.size()*4);
        float labelPosition = this.x+leftOffsetX+ axisLength/(this.data.size()*2);
        int count =1;
        float textSize = getTextSizeChart(axisLength/data.size(),offsetY,data.get(0).getKey().length());
        for(Mapping m: this.data)
        { 
            textSize = Math.min(getTextSizeChart(axisLength,offsetY,m.getKey().length()),textSize); //should actually be Math.min(getTextSize(axisLength/(xValues.size()),offsetY,s.length()),textSize) but that makes the text too small
        } 
        textAlign(CENTER,TOP);
        textSize(textSize);
        noStroke();
        for(int i =0;i<this.data.size();i++)
        {
            fill(barColors.get(i));
            rectMode(CORNERS);
            rect(columnPosition,this.y+this.gHeight-offsetY-(axisYLength*(this.data.get(i).getValue()/maxValue)), columnPosition+ axisLength/(this.data.size()*2), this.y+this.gHeight-offsetY);
            columnPosition += increment;
            fill(255);
            text(this.data.get(i).getKey(),labelPosition, this.y+this.gHeight-offsetY);
            labelPosition += increment;
        }
        popStyle();
    }

    //function to reset and update graphv
    public void setGraph(ArrayList<Mapping> data, String title, String xALabel, String yALabel)
    {
        this.xALabel = xALabel; this.yALabel = yALabel;
        this.data = data;
        this.title = title;
        createBarColors();
    }
    
    //function to reset and update graph
    public void setGraph(ArrayList<Mapping> data)
    {
        this.data = data;
        createBarColors();
    }

    //function to add different colors to the bar chart
    private void createBarColors()
    {
        if(this.barColors != null & this.data.size() != this.barColors.size())
        {
            this.barColors.clear();
            Random r = new Random();
            for(int i =0; i< this.data.size();i++)
            {
                int blueValue = r.nextInt(100)+100;
                int greenValue = r.nextInt(blueValue/2);
                this.barColors.add(color(0,greenValue,blueValue));
            }
        }
    }
}
//Class created by B. Pusch
//Used for pressing buttons
public class ButtonWidget extends Widget
{
    String label;
    int labelColor,buttonSelectedColor, buttonColor;
    boolean hover;
    static final int RECT_RADII = 8;
    float fontSize;

    //widget constructor (without font size argument) created by B.Pusch
    public ButtonWidget(float fx, float fy, float fwidth, float fheight, String label, int event)
    {
        super(fx,fy,fwidth,fheight,event);
        this.label = label;
        this.buttonColor = color(255);
        this.buttonSelectedColor = color(100);
        this.labelColor = color(0);
        this.hover = false;
        this.fontSize = -1;
    }

    //widget constructor to incorporate font sizecreated by B.Pusch
    public ButtonWidget(float fx, float fy, float fwidth, float fheight, String label, int event, float fontSize)
    {
        super(fx,fy,fwidth,fheight,event);
        this.label = label;
        this.buttonColor = color(255);
        this.buttonSelectedColor = color(100);
        this.labelColor = color(0);
        this.hover = false;
        this.fontSize = fontSize/1000;
    }
    // created by B.Pusch
    public void draw(){
        
        pushStyle();
        noStroke();
        if(hover)
            fill(buttonSelectedColor);
        else
            fill(buttonColor);
        rect(x,y,wWidth,wHeight,RECT_RADII);
        //draw text on widget
        textAlign(CENTER, CENTER);
        if (this.fontSize == -1)
            textSize(getTextSizeChart(this.wWidth, this.wHeight, label.length()));
        else
            textSize(this.fontSize*width);
        fill(this.labelColor);
        text(label,x,y,wWidth,wHeight);
        popStyle();
    }

    //function to get and return mouse event created by B.Pusch
     public int getEvent(MouseEvent e)
    { 
        if( (mouseX >= this.x && mouseX < this.x+this.wWidth)
            &&
            (mouseY >= this.y && mouseY < this.y+this.wHeight))
        {
            this.hover = true;
            if (e.getAction() == MouseEvent.RELEASE)
            {
                this.hover = false;
                return this.event;
            }
        }
        else
        {
            this.hover = false;
        }
        return NULL_EVENT;
    }



    

}
//Created by B. Pusch
//Constants used in the project

//1 - 10 are global events --> will be accesed in main
//10 onwards are uniqeu to each screen and can overlap --> won't be accessed in main
final int NULL_EVENT = 0;
final int HOME_SCREEN = 1;
final int COUNTRY_SCREEN = 2;
final int ALTITUDE_SCREEN = 3;
final int GLOBE_SCREEN = 4;
final int TIME_SCREEN = 5;
final int GRAPH_SCREEN = 6;
final int AI_SCREEN = 7;

final int MINIMUM_YEAR = 1958;
final int MAXIMUM_YEAR = 2022;
final int MINIMUM_PERIGEE = -1600;
final int MAXMIM_PERIGEE = 244195;
final int MINIMUM_APOGEE = -4788696;
final int MAXIMUM_APOGEE = 2280262;

//Class created by B. Pusch
//Screen for countries query
public class CountriesScreen extends Screen
{
    private float fHeaderHeight, fuIx, headerHeight, uIx, fuIWidth, uIWidth, fuIy, uIy, fuIHeight, uIHeight;
    private ArrayList<Mapping> data;
    private String year;
    private static final int sliderEvent = 11;
    private static final int updateButtonEvent = 12;
    
    public CountriesScreen()
    {
        super();
        this.screenColour = color(58,72,90);
        this.fHeaderHeight = .05f;
        this.fuIx = .66f;
        this.headerHeight = height*fHeaderHeight;
        this.uIx = width*fuIx;
        this.year = "1960";
        this.fuIWidth = .29f;
        this.uIWidth = width*fuIWidth;
        this.fuIy = .1f;
        this.uIy = fuIy*height;
        this.fuIHeight = .85f;
        this.uIHeight = height*fuIHeight;
        data = new ArrayList<Mapping>();
        updateLaunchesVsCountryPerYear();
        screenGraphs.add(new PieChart(0,fHeaderHeight,fuIx,1-fHeaderHeight, "Number of Satellites by Country in "+ this.year,this.data));
        screenWidgets.add(new ButtonWidget(.01f,.01f,(fHeaderHeight-.01f)*2, fHeaderHeight-.02f,"Return",GRAPH_SCREEN)); 
        screenWidgets.add(new Slider(fuIx+.02f,.74f, fuIWidth-.02f*2,.07f,sliderEvent));
        screenWidgets.add(new ButtonWidget(fuIx+.02f,.8f,fuIWidth-.02f*2,.1f,"Update Graph", updateButtonEvent));
    }

    //created by B.Pusch
    public void draw()
    {
        pushStyle();    
        background(0);
        noStroke();
        //draw header
        fill(color(32,33,36));
        rect(0,0,width,headerHeight);
        //draw title 
        fill(255);
        textSize(getTextSizeChart(uIWidth,.1f*height,10));
        textAlign(CENTER, BOTTOM);
        text("Year: " + this.year,(uIx+uIx+uIWidth)/2,.72f*height);
        //draw legend and slider
        drawUI();
        drawLegend();
        popStyle();
        super.draw();    
    }

    //function to draw the UI created by B.Pusch
    private void drawUI()
    {
        pushStyle();
        stroke(200);
        strokeWeight(2);
        fill(50);
        rect(uIx, uIy, uIWidth,uIHeight,8);
        popStyle();
    }

    //function to draw and update legend created by B.Pusch
    private void drawLegend()
    {
        pushStyle();
        ArrayList<Mapping> colors = ((PieChart)this.screenGraphs.get(0)).getColors();
        float legendX = uIx+.1f*uIWidth;
        float legendWidth = uIWidth*.8f;
        float legendY = uIy+.08f*uIHeight;
        float legendHeight = .6f*uIHeight;
        rect(legendX,legendY,legendWidth,legendHeight,6);
        float entryHeight = legendHeight/11;
        float entryOffset = legendHeight/11/2;
        int count = 0;
        int otherTotal = 0;
        MappingKeyComparator comp = new MappingKeyComparator();
        stroke(0);
        rectMode(CENTER);
        textAlign(LEFT,CENTER);
        textSize(.6f*entryHeight);
        for(Mapping c: this.data)
        {
            if(count<9)
            {
                fill(colors.get(Collections.binarySearch(colors,c,comp)).getValue());
                rect(legendX+.05f*legendWidth+entryHeight/2,legendY+entryOffset+ entryHeight*count+ entryHeight/2,entryHeight*.7f,entryHeight*.7f);
                fill(0);
                text(" " +c.getKey() + " | Count: " + c.getValue(),legendX+.05f*legendWidth+entryHeight*.7f ,legendY+entryOffset+ entryHeight/2 + entryHeight*count);
            }
            else
                otherTotal += c.getValue();
            count++;
        }
        if(count>=9)
        {
            fill(color(100,100,150));
            rect(legendX+.05f*legendWidth+entryHeight/2,legendY+entryOffset+ entryHeight*9 + entryHeight/2,entryHeight*.7f,entryHeight*.7f);
            fill(0);
            text(" Other | Count: " + otherTotal,legendX+.05f*legendWidth+ entryHeight*.7f,legendY+entryOffset+ entryHeight/2+ entryHeight*9); 
        }       
        popStyle();
    }
    
    //function to get event 
    public int getEvent(MouseEvent e)
   {
       int event;
       for(Widget w: screenWidgets)
       {
           event = w.getEvent(e);
           switch(event)
           {
                case updateButtonEvent:
                    updateLaunchesVsCountryPerYear();
                    ((PieChart)screenGraphs.get(0)).setGraph(this.data); 
                    return event;
                case sliderEvent:
                    this.year = String.valueOf((int)(MINIMUM_YEAR+ (MAXIMUM_YEAR-MINIMUM_YEAR)*((Slider) screenWidgets.get(1)).getFractionOfSlider()));
                    screenGraphs.get(0).setTitle("Number of Satellites by Country in "+ this.year);
                    return event;
                case GRAPH_SCREEN:
                    return event;
           }
       }
       return NULL_EVENT;
   }
   
   // queries data to update displayed graphical information
   private void updateLaunchesVsCountryPerYear()
   {
       if(data != null)
            this.data.clear();
        String regex = "("+ this.year+ ").*";
       for(TableRow row: gcat.matchRows(regex,"LDate"))
        {
            try
            {
                Mapping category = new Mapping(orgs.findRow(row.getString("State"),"StateCode").getString("ShortEName"));
                if(category != null && !data.contains(category))
                    data.add(category);
                else if(data.contains(category))
                    this.data.get(this.data.indexOf(category)).increment();
            }
            catch(Exception e) {continue;}
        }   
   }

    //function to update and resize screen
    public void resize()
   {
       super.resize();
       this.headerHeight = fHeaderHeight*height;
       this.uIWidth = fuIWidth*width;
       this.uIx = fuIx*width;
       this.uIy = fuIy*height;
       this.uIHeight = fuIHeight*height;
   }
}
//Class created by L. Chow
//Object for a dot plot
public class DotPlot extends Graph
{
    private ArrayList<Float> data;
    private ArrayList<Integer> year;
    private String xALabel, yALabel;

    public DotPlot(float fx, float fy, float fwidth, float fheight,String title, ArrayList<Float> data,ArrayList<Integer> year, String xALabel, String yALabel)
    { 
        super(fx,fy,fwidth,fheight,title);
        this.xALabel = xALabel; 
        this.yALabel = yALabel;
        this.data = data;
        this.year = year;
    }

    public void draw()
    {
        pushStyle();
        //calculating offset
        float leftOffsetX = this.gWidth*.1f;
        float rightOffsetX = this.gWidth *.2f;
        float offsetY = this.gHeight*.1f;
        //display title
        fill(255);
        textSize(getTextSizeChart(gWidth,offsetY,this.title.length()));
        textAlign(CENTER,TOP);
        text(this.title,this.gWidth/2+this.x,this.y);
        //draw axes and dots
        drawAxes(leftOffsetX, rightOffsetX, offsetY);
        drawDot(leftOffsetX, rightOffsetX, offsetY);
        popStyle();
    }

    //function to draw axes and x and y axis labels
    private void drawAxes(float leftOffset, float rightOffset, float offsetY)
    {
        pushStyle();
        strokeWeight(1);
        stroke(255);
        line(this.x+leftOffset,this.y+offsetY,this.x+leftOffset,this.y+this.gHeight-offsetY);
        line(this.x+leftOffset,this.y+this.gHeight-offsetY,this.x+this.gWidth-rightOffset,this.y+this.gHeight-offsetY);
        timeLabels(leftOffset, offsetY);
        drawHashMarks(leftOffset, offsetY);
        fill(255);
        textAlign(CENTER, BOTTOM);
        textSize(20*height/800);
        text(this.yALabel,this.x+leftOffset,this.y+offsetY-20);
        textAlign(LEFT,CENTER);
        text(this.xALabel, this.x+this.gWidth-rightOffset+50*width/1000,this.y+this.gHeight-offsetY);
        popStyle();
    }

    //function called in drawAxes() to draw the lines and caluculate the values of the y axis 
    private void drawHashMarks(float leftOffset, float offsetY)
    {
        pushStyle();
        float maxValue =Collections.max (this.data);
        float minValue = Collections.min(this.data);
        float axisLength = this.gHeight*.8f;
        stroke(255);
        fill(255);
        textAlign(RIGHT,CENTER);
        for(int i = 1;i<=5;i++)
            {
                float hashHeight = this.y+this.gHeight-offsetY-axisLength/5*i;
                line(this.x+leftOffset,hashHeight,this.x+leftOffset+10, hashHeight);
                String hashLabel = Integer.toString((int)(maxValue/5.0f*i)) + " ";
                textSize(getTextSizeChart(leftOffset,axisLength/15,hashLabel.length()));
                text(hashLabel,this.x+leftOffset,hashHeight);
            } 
        popStyle();
    }

    //function to find the x and y coordinates of the object to places the corresponding dot
    private void drawDot(float leftOffset, float rightOffset, float offsetY)
    {
        pushStyle();
        float maxValue =Collections.max (this.data);
        float minValue = Collections.min(this.data);
        float maxYear =Collections.max (this.year);
        float minYear = Collections.min(this.year);
        for (int i = 0; i < this.data.size(); i++) 
        {
            float x = map(year.get(i), minYear, maxYear, this.x+leftOffset,this.x+this.gWidth-rightOffset);
            float y = map(data.get(i), minValue, maxValue, this.y+this.gHeight-offsetY, this.y+offsetY);
            strokeWeight(5);
            fill(color(0,100,200));
            stroke(color(0,100,200));
            point(x, y);
        }
        popStyle();
    }

    //function called in drawAxes() to draw the lines and calculate the values of the x axis
    private void timeLabels(float leftOffset, float offsetY)
    {
        pushStyle();
        float maxValue =Collections.max (this.year);
        float minValue =Collections.min (this.year);
        float axisLength = this.gWidth*.7f;
        stroke(255);
        fill(255);
        textAlign(CENTER,TOP);
        float xLabelMove = this.x+leftOffset;
        for(int i = 1;i<=8;i++)
            {
                line(xLabelMove+87.5f,this.y+this.gHeight-offsetY,xLabelMove+87.5f, this.y+this.gHeight-offsetY+10);
                String hashLabel =  Integer.toString((int)(minValue+(maxValue-minValue)/8*i)) + " ";
                textSize(getTextSizeChart(leftOffset,axisLength/8,hashLabel.length()));
                text(hashLabel,xLabelMove+leftOffset,this.y+this.gHeight-offsetY+5);
                xLabelMove+=axisLength/8;
            } 
        popStyle();
    }

    //function to reset and update graph
    public void setGraph(ArrayList<Float> data,ArrayList<Integer> year, String title, String xALabel, String yALabel)
    {
        this.xALabel = xALabel; this.yALabel = yALabel;
        this.data = data;
        this.year = year;
        this.title = title;
    }
    //function to reset and update graph
    public void setGraph(ArrayList<Float> data, ArrayList<Integer> year)
    {
        this.data = data;
        this.year = year;
    }
}
//Class created by B. Pusch
//Screen for the globe query
public class GlobeScreen extends Screen
{
    private float fradius, radius;
    private float sfx,sfy,sx,sy,sz,hx,hy;
    private PShape globe;
    private ArrayList<Orbit> orbits;
    private ArrayList<String[]> data; //jcat,satcat,type,name,ldate,mass,perigee,apogee,inc,oporbit,raan,ecc
    private ArrayList<String[]> displayedData; //jcat, satcat, type,name,ldate,mass,perigee,apogee,inc,oporbit,raan,ecc
    private static final int jcat =0; private static final int satcat =1; private static final int type =2;private static final int name =3;private static final int ldate =4;private static final int mass =5;
    private static final int perigee =6; private static final int apogee=7; private static final int inc =8;private static final int oporbit =9;private static final int raan =10;private static final int ecc =11;
    float xUIDivider, UIWidth, yUIDivider, UIHeight;
    static final int toggleUIButtonEvent = 11;
    static final int textBoxEvent = 12;
    static final int resetHighlightEvent = 13;
    static final int updateButtonEvent = 14;
    static final int helpButtonEvent = 15;
    static final int orbitMenuEvent = 16;
    static final int maxOrbitsDisplayed = 200;
    static final int infographicWidth = 960;
    static final int infographicHeight = 540;
    boolean hideUI;
    boolean showHelp;

    public GlobeScreen() 
    {
        this.screenColour = color(0);
        this.xUIDivider = .725f;  this.UIWidth = .25f; this.yUIDivider = .1f; this.UIHeight = .8f;
        screenWidgets.add(new ButtonWidget(.01f,.01f,0.08f, 0.03f,"Return",HOME_SCREEN));  
        screenWidgets.add(new ButtonWidget(xUIDivider+.01f+.12f,.01f,0.12f, 0.03f,"Toggle UI",toggleUIButtonEvent));
        screenWidgets.add(new ButtonWidget(.775f,.825f,.15f,.05f, "Update", updateButtonEvent));
        screenWidgets.add(new ButtonWidget(xUIDivider,.01f,.12f,.03f,"Help",helpButtonEvent));
        screenWidgets.add(new ButtonWidget(.595f,.01f,.12f,.03f,"Reset", resetHighlightEvent));
        screenWidgets.add(new OrbitMenu(.75f,.23f,.2f,.57f,this.orbitMenuEvent));
        screenWidgets.add(new TextBox(.75f,.15f,.2f,.05f,textBoxEvent,"Alphanumeric"));
        this.sfx = .5f; this.sfy = .5f; this.sz = 0;
        this.fradius = .35f;
        this.orbits = new ArrayList<Orbit>();
        this.data = new ArrayList<String[]>();
        this.displayedData = new ArrayList<String[]>();
        this.sx = this.sfx*width; this.sy = this.sfy*height; 
        this.hx = (int) ((float) (width / 2) - (float) (infographicWidth / 2)); this.hy = (int) ((float) (height / 2) - (float) (infographicHeight / 2));
        this.radius = Math.min(width,height)*fradius;
        noStroke();
        noFill();
        query("random");
        this.hideUI = false;
        this.showHelp = false;
        this.globe = createShape(SPHERE, this.radius);
        this.globe.setTexture(earthIm);  
    }

    //Modified by G. Mullen to include a help screen infographic
    public void draw()
    { 
        pushStyle();
        background(this.screenColour);
        cam.endHUD();
        noStroke();
        lights();
        pushMatrix();
        translate(this.sx,this.sy,this.sz);
        shape(this.globe);
        popMatrix();
        int count = 0;
        for(Orbit o: this.orbits)
        {
            o.draw();
        }
        cam.beginHUD();
        if(!hideUI)
        {
            fill(50);
            strokeWeight(2);
            stroke(200);
            rect(width*xUIDivider,height*this.yUIDivider, this.UIWidth*width, this.UIHeight*height,8);
            fill(255);
            rect(.75f*width,.23f*height,.2f*width,.57f*height);
            screenWidgets.get(2).draw();
            screenWidgets.get(5).draw();
            screenWidgets.get(6).draw();
        }
        if(showHelp)
        {
            background(0);
            image(infographic, hx, hy);
        }
        screenWidgets.get(0).draw();
        screenWidgets.get(1).draw();
        screenWidgets.get(3).draw();
        screenWidgets.get(4).draw();
        popStyle();
    }

    //Modified by G. Mullen to prevent UI elements from being accessed while help is shown or UI is hidden
    public int getEvent(MouseEvent e)
    {
        int event;
        for(Widget w: screenWidgets)
        {
            event = w.getEvent(e);
            switch(event) {
                case toggleUIButtonEvent:
                    if(!showHelp) this.hideUI = !this.hideUI;
                    return toggleUIButtonEvent;
                case helpButtonEvent:
                    this.showHelp = !this.showHelp;
                    return helpButtonEvent;
                case HOME_SCREEN:
                    cam.setActive(false);
                    return event;
                case textBoxEvent:
                    return textBoxEvent;
                case updateButtonEvent:
                    if(!showHelp) {
                        query(((TextBox)screenWidgets.get(6)).getString());
                        ((OrbitMenu)screenWidgets.get(5)).resetIndex();
                    } return updateButtonEvent;
                case resetHighlightEvent:
                    if(!showHelp) {
                        for(Orbit o:orbits)
                            o.setSelected(false);
                    } return resetHighlightEvent;
                case orbitMenuEvent:
                    if(!showHelp) {
                        if(((OrbitMenu)w).isGetID())
                        {
                            String id = ((OrbitMenu)w).getID();
                            Orbit oID = new Orbit(id,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f);
                            Collections.sort(this.orbits, new OrbitComparator()); 
                            int index = Collections.binarySearch(this.orbits, oID, new OrbitComparator());
                            if(index>=0)
                            {
                                orbits.get(index).setSelected(true);
                            }
                            else
                            {
                                index = (index+1)*-1;
                                String aID[] = {"",id, "", "","", "", "","","", "", "","" };
                                String s[] = this.data.get(Collections.binarySearch(this.data, aID, new GlobeDataComparator()));
                                this.orbits.add(index,  new Orbit(s[satcat], Float.parseFloat(s[ecc]), Float.parseFloat(s[apogee]),
                                                Float.parseFloat(s[perigee]), Float.parseFloat(s[inc]), Float.parseFloat(s[raan]),
                                                this.sx,this.sy,this.radius ));
                                orbits.get(index).setSelected(true);
                                this.displayedData.add(s);
                            }
                        }
                        else
                            return NULL_EVENT;
                    }
            }
        }
        return NULL_EVENT;
    }
    
    public float getSphereX()
    {
        return this.sx;
    }

    public float getSphereY()
    {
        return this.sy;
    }

     public void resize()
    {
        super.resize();
        this.sx = this.sfx*width; this.sy = this.sfy*height; 
        this.hx = (int) ((float) (width / 2) - (float) (infographicWidth / 2)); this.hy = (int) ((float) (height / 2) - (float) (infographicHeight / 2));
        //this.radius = Math.min(width,height)*fradius;
        for(Orbit o: this.orbits)
            o.resize(this.sx,this.sy);  
    }

    //overall check --> "(D:[0-9]{4}-[0-9]{4})|(N:.+)|(T:(Debris-Fragmentation)|T:(Debris-Component)|T:(Debris)|T:(Humans)|T:(ISS)|T:(Suborbital))|((A:-*[0-9]+\\.[0-9]*|A:-*[0-9]+)-(-*[0-9]+\\.[0-9]*|-*[0-9]+))|((P:-*[0-9]+\\.[0-9]*|P:-*[0-9]+)-(-*[0-9]+\\.[0-9]*|-*[0-9]+))|((R:-{0,1}[0-9]+\\.[0-9]*|R:-{0,1}[0-9]+)-(-{0,1}[0-9]+\\.[0-9]*|-{0,1}[0-9]+);(-{0,1}[0-9]+\\.[0-9]*|-{0,1}[0-9]+)-(-{0,1}[0-9]+\\.[0-9]*|-{0,1}[0-9]+))|((M:-*[0-9]+\\.[0-9]*|M:-*[0-9]+)-(-*[0-9]+\\.[0-9]*|-*[0-9]+))|(O:(LLEO)|O:(LEO)|O:(MEO)|O:(HEO)|O:(GTO)|O:(GEO)|O:(VHEO)|O:(DSO)|O:(CLO))"
    //D:year>year or year --> all satellites that were launched in that year or year range
    //N:name --> all satellites with that name (not exact name)
    //T:sattelite type --> this is going to be difficult --> https://planet4589.org/space/gcat/web/intro/type.html
    //this program will use:
    //      Debris (fragmentation debris and component debris), with humans on board, ISS related, suborbital payloads,
    //A:a1-a2 --> all satellites in that apogee range
    //P:p1-p2 --> all satellites in that perigee range
    //R:a1-a2;p1-p2 --> all satellites in that apogee and that perigee range
    //M:m1-m2 --> all satellites in that mass range
    //O:orbit type --> all satellites in that orbit type (will probably have to do a random subset because there are too many   )
    
    // sets up a method by which all object data can be organized and visualized through queries by filtering based on string input using regular expressions
     public void query(String input)
    {   
        String regex = "(random)"+
                        "|(D:[0-9]{4}>[0-9]{4})" +
                        "|(N:.+)"+
                        "|(T:(Debris-Fragmentation)|T:(Debris-Component)|T:(Debris)|T:(Human)|T:(ISS)|T:(Suborbital))"+
                        "|((A:-*[0-9]+\\.[0-9]*|A:-*[0-9]+)>(-*[0-9]+\\.[0-9]*|-*[0-9]+))"+
                        "|((P:-*[0-9]+\\.[0-9]*|P:-*[0-9]+)>(-*[0-9]+\\.[0-9]*|-*[0-9]+))"+
                        "|((R:-{0,1}[0-9]+\\.[0-9]*|R:-{0,1}[0-9]+)>(-{0,1}[0-9]+\\.[0-9]*|-{0,1}[0-9]+);(-{0,1}[0-9]+\\.[0-9]*|-{0,1}[0-9]+)>(-{0,1}[0-9]+\\.[0-9]*|-{0,1}[0-9]+))"+
                        "|((M:-*[0-9]+\\.[0-9]*|M:-*[0-9]+)>(-*[0-9]+\\.[0-9]*|-*[0-9]+))"+
                        "|(O:(LLEO)|O:(LEO)|O:(MEO)|O:(HEO)|O:(GTO)|O:(GEO)|O:(VHEO)|O:(DSO)|O:(CLO))";
        regex = regex.toLowerCase();
        input = input.toLowerCase();
        if(Pattern.matches(regex,input.toLowerCase()))
        {
            if(input.equalsIgnoreCase("random"))
            {
                if(updateData(".","#JCAT"))
                {
                    updateDisplayedData();
                }
            }
            else
            {
                float min,max;
                switch(input.charAt(0))
                {
                    case 'd':
                        min = Integer.parseInt(input.substring(2,6));
                        max = Integer.parseInt(input.substring(7,11));
                        if(min<=max && min>=1958 && max<=2022)
                        {
                            if(updateData(min,max,"LDate"))
                                updateDisplayedData();
                        }
                        break;
                    case 'n':
                        input = input.substring(2,input.length());
                        regex = "(";
                        for(int i = 0;i<input.length();i++)
                        {

                            regex += ""+'[' + input.charAt(i) + Character.toUpperCase(input.charAt(i)) + ']';
                        }
                        regex += ").*";
                        if(updateData(regex,"Name"))
                        {
                            updateDisplayedData();
                        }
                        break;
                    case 't':
                        input = input.substring(2,input.length());
                        if(input.equalsIgnoreCase("Debris-Fragmentation"))
                            regex = "^[Dd].*";
                        else if (input.equalsIgnoreCase("Debris-Component"))
                            regex = "^[Cc].*";
                        else if (input.equalsIgnoreCase("Debris"))
                            regex = "^[CcDd].*";
                        else if (input.equalsIgnoreCase("Human"))
                            regex = "^[PpSs][Hh].*";
                        else if (input.equalsIgnoreCase("ISS"))
                            regex = "^.{5}[IiCcDdMmVv]{1}.*";
                        else if (input.equalsIgnoreCase("Suborbital"))
                            regex = "^[Ss].*";
                        if(updateData(regex,"Type"))
                            updateDisplayedData();
                        break;
                    case 'a':
                        min = Float.parseFloat(input.substring(2,input.indexOf('>')));
                        max = Float.parseFloat(input.substring(input.indexOf('>')+1,input.length()));
                        if(min<=max)
                        {
                            if(updateData(min,max,"Apogee"))
                                updateDisplayedData();
                        }
                        break;
                    case 'p':
                        min = Float.parseFloat(input.substring(2,input.indexOf('>')));
                        max = Float.parseFloat(input.substring(input.indexOf('>')+1,input.length()));
                        if(min<=max)
                        {
                            if(updateData(min,max,"Perigee"))
                                updateDisplayedData();
                        }
                        break;
                    case 'r':
                        min = Float.parseFloat(input.substring(2,input.indexOf('>')));
                        max = Float.parseFloat(input.substring(input.indexOf('>')+1,input.indexOf(';')));
                        float min2 = Float.parseFloat(input.substring(input.indexOf(';')+1,input.indexOf('>',input.indexOf(';'))));
                        float max2 = Float.parseFloat(input.substring(input.indexOf('>',input.indexOf(';'))+1, input.length()));
                        if(min<=max && min2<max2)
                        {
                            if(updateData(min,max, min2, max2,"Apogee", "Perigee"))
                                updateDisplayedData();
                        }
                        break;
                    case 'm':
                        min = Float.parseFloat(input.substring(2,input.indexOf('>')));
                        max = Float.parseFloat(input.substring(input.indexOf('>')+1,input.length()));
                        if(min<=max)
                        {
                            if(updateData(min,max,"Mass"))
                                updateDisplayedData();
                        }
                        break;
                    case 'o':
                        input = input.substring(2,input.length());
                        if(input.equalsIgnoreCase("LLEO"))
                            regex = "^([Ll][Ll][Ee][Oo]).*";
                        else if (input.equalsIgnoreCase("LEO"))
                            regex = "^([Ll][Ee][Oo]).*";
                        else if (input.equalsIgnoreCase("MEO"))
                            regex = "^([Mm][Ee][Oo]).*";
                        else if (input.equalsIgnoreCase("HEO"))
                            regex = "^([Hh][Ee][Oo]).*";
                        else if (input.equalsIgnoreCase("GTO"))
                            regex = "^([Gg][Tt][Oo]).*";
                        else if (input.equalsIgnoreCase("GEO"))
                            regex = "^([Gg][Ee][Oo]).*";
                        else if (input.equalsIgnoreCase("VHEO"))
                            regex = "^([Vv][Hh][Ee][Oo]).*";
                        else if (input.equalsIgnoreCase("DSO"))
                            regex = "^([Dd][Ss][Oo]).*";
                        else if (input.equalsIgnoreCase("CLO"))
                            regex = "^([Cc][Ll][Oo]).*";
                        if(updateData(regex,"OpOrbit"))
                            updateDisplayedData();
                        break;
                }
            }
        }
    }

     public boolean updateData(float min, float max, String columnName)
    {
        boolean hasData = true;
        for(TableRow row:activeSatellites.rows())
        {
            String value = columnName.equals("LDate")? row.getString(columnName).substring(0,4):row.getString(columnName);
            if(Float.parseFloat(value)<=max && Float.parseFloat(value)>=min)
            {
                if(hasData && this.data != null)
                {
                    this.data.clear();
                }
                hasData = false;
                String tempArray[] = {row.getString("#JCAT"),row.getString("Satcat"), row.getString("Type"), row.getString("Name"),
                                    row.getString("LDate"), row.getString("Mass"), row.getString("Perigee"),row.getString("Apogee"),
                                    row.getString("Inc"), row.getString("OpOrbit"), row.getString("raan"),row.getString("ecc") };
                this.data.add(tempArray);
            }
        }
        if(!hasData)
            ((OrbitMenu)screenWidgets.get(5)).addData(this.data);
        return !hasData;
    }

     public boolean updateData(float min1, float max1, float min2, float max2, String columnName1, String columnName2)
    {
        boolean hasData = true;
        for(TableRow row:activeSatellites.rows())
        {
            String value1 = row.getString(columnName1);
            String value2 = row.getString(columnName2);
            if(Float.parseFloat(value1)<=max1 && Float.parseFloat(value1)>=min1 && Float.parseFloat(value2)<=max2 && Float.parseFloat(value2)>=min2)
            {
                if(hasData && this.data != null)
                {
                    this.data.clear();
                }
                hasData = false;
                String tempArray[] = {row.getString("#JCAT"),row.getString("Satcat"), row.getString("Type"), row.getString("Name"),
                                    row.getString("LDate"), row.getString("Mass"), row.getString("Perigee"),row.getString("Apogee"),
                                    row.getString("Inc"), row.getString("OpOrbit"), row.getString("raan"),row.getString("ecc") };
                this.data.add(tempArray);
            }
        }
        if(!hasData)
            ((OrbitMenu)screenWidgets.get(6)).addData(this.data);
        return !hasData;
    }

     public boolean updateData(String regex, String columnName)
    {
        boolean hasData = true;
        for(TableRow row: activeSatellites.matchRows(regex,columnName))
        {
            if(hasData && this.data != null)
            {
                this.data.clear();
            }
            hasData = false;
            String tempArray[] = {row.getString("#JCAT"),row.getString("Satcat"), row.getString("Type"), row.getString("Name"),
                                    row.getString("LDate"), row.getString("Mass"), row.getString("Perigee"),row.getString("Apogee"),
                                    row.getString("Inc"), row.getString("OpOrbit"), row.getString("raan"),row.getString("ecc") };
            this.data.add(tempArray);
        }
        if(!hasData)
            ((OrbitMenu)screenWidgets.get(5)).addData(this.data);
        return !hasData;
    }

     public void updateDisplayedData()
    {
        if(this.orbits != null)
        {
            this.orbits.clear();
        }
        if(this.displayedData != null)
        {
            this.displayedData.clear();
        }
            
        if(this.data.size() < maxOrbitsDisplayed)
        {
            this.displayedData = (ArrayList<String[]>)this.data.clone();
        }
        else
        {
            Collections.shuffle(this.data);
            int count =0;
            for(String s[]: this.data)
            { //used to be a try an catch here with the orbit constructor
                if(count>= maxOrbitsDisplayed)
                    break;
                this.displayedData.add(s);
                count++;
            }
        }
        for(String s[]: this.displayedData)
        {
            
            this.orbits.add(new Orbit(s[satcat], Float.parseFloat(s[ecc]), Float.parseFloat(s[apogee]),
                            Float.parseFloat(s[perigee]), Float.parseFloat(s[inc]), Float.parseFloat(s[raan]),
                            this.sx,this.sy,this.radius ));
        }
        Collections.sort(this.orbits, new OrbitComparator());   
        Collections.sort(this.data, new GlobeDataComparator());
    }
}
//Class created by B. Pusch
//Superclass for graphs

abstract public class Graph
{
    float fx, fy, fwidth, fheight;
    float x,y,gWidth,gHeight;
    String title;
    int backGroundColor, primaryColor;

    public Graph(float fx, float fy, float fwidth, float fheight,String title)
    {
        this.fx = fx; this.fy = fy; this.fwidth = fwidth; this.fheight = fheight;
        
        resize();

        this.title = title;
        this.backGroundColor = color(255);
        this.primaryColor = color(0);
    }

    public void setTitle(String title)
    {
        this.title = title;
    }

     public abstract void draw();
     public void resize()
    {
        this.gWidth = width * fwidth;
        this.gHeight =  height * fheight;
        this.x = width * fx;
        this.y = height * fy;
    }
}
//Class created by L. Chow
//Screen to choose which graph to enquire
public class GraphScreen extends Screen 
{
    private Planet sun;
    private Star[] stars;
    private String title;
    private float fHeaderHeight;

    public GraphScreen()
    {
        super();
        this.screenColour = color(0);
        this.fHeaderHeight = .05f;
        //add widgets to go to the different screen
        this.title = "Please choose a visualization of the data";
        screenWidgets.add(new ButtonWidget(2/12.0f,.8f,2.0f/12.0f,1.0f/12.0f,"Pie Chart",COUNTRY_SCREEN));
        screenWidgets.add(new ButtonWidget(5/12.0f,.8f,2.0f/12.0f,1.0f/12.0f,"Bar Chart",ALTITUDE_SCREEN));
        screenWidgets.add(new ButtonWidget(8/12.0f,.8f,2.0f/12.0f,1.0f/12.0f,"Dot Plot",TIME_SCREEN));
        screenWidgets.add(new ButtonWidget(.01f,.01f,(fHeaderHeight-.01f)*2, fHeaderHeight-.02f,"Return",HOME_SCREEN)); 
        //create sun object
        sun = new Planet (90, 0, 0, sunIm);
        //create and make stars
        stars = new Star[500];
        for (int i =0; i<stars.length; i++)
        {
            stars[i] = new Star();
        }
        //create planets
        sun.addPlanets(8); 
    }

    public void draw()
    {
        pushStyle();
        background(this.screenColour);
        super.draw();
        //draw stars
        pushMatrix();
        translate(width/2,height/3);
        for (int i =0; i<stars.length; i++)
        {
            stars[i].update();
            stars[i].drawStars();
        }
        popMatrix();
        //draw planets
        pushMatrix();
        translate(width/2,height/3);
        sun.drawPlanet();
        sun.orbit();
        popMatrix();
        fill(255);
        textAlign(CENTER,BOTTOM);
        textSize(getTextSize(width*.33f,height*.1f,this.title.length()));
        text(this.title, width*.5f, height*.75f);
    }

    //function to go to the graphs
    public int getEvent(MouseEvent e)
   {
       int event;
       for(Widget w: screenWidgets)
       {
           event = w.getEvent(e);
           switch(event)
           {
               case ALTITUDE_SCREEN:
                return event;
               case TIME_SCREEN:
                return event;
               case COUNTRY_SCREEN:
                return event;
               case HOME_SCREEN:
                return event;
           }
       }
       return NULL_EVENT;
   }
    public void resize()
   {
       super.resize();
   }
}
//Created created by L. Chow
//Class for the homescreen object
public class HomeScreen extends Screen
{
    private Planet sun;
    private String title, choose;
    private Star[] stars;

    static final int toggleAudioEvent = 11;
    static final int exitEvent = 12;

    public HomeScreen()
    {
        super();
        this.screenColour = color(0);
        //add widgets to go to the different screen
        screenWidgets.add(new ButtonWidget(5/12.0f,.8f,2.0f/12.0f,1.0f/12.0f,"Graph",GRAPH_SCREEN));
        screenWidgets.add(new ButtonWidget(8/12.0f,.8f,2.0f/12.0f,1.0f/12.0f,"Globe",GLOBE_SCREEN));
        screenWidgets.add(new ButtonWidget(2/12.0f,.8f,2.0f/12.0f,1.0f/12.0f, "AI",AI_SCREEN));
        screenWidgets.add(new ButtonWidget(.01f,.01f,0.08f, 0.03f,"Mute Audio",toggleAudioEvent));
        screenWidgets.add(new ButtonWidget(.91f,.01f,0.08f, 0.03f,"Exit",exitEvent));
        this.title = "Welcome!";
        this.choose = "Please choose a query of the data";
        //create sun object
        sun = new Planet (100, 0, 0, sunIm);
        //create and make stars
        stars = new Star[500];
        for (int i =0; i<stars.length; i++)
        {
            stars[i] = new Star();
        }
        //create planets
        sun.addPlanets(8); 
    }

    public void draw()
    {
        pushStyle();
        background(this.screenColour);
        super.draw();
        //draw stars
        pushMatrix();
        translate(width/2,height/2);
        for (int i =0; i<stars.length; i++)
        {
            stars[i].update();
            stars[i].drawStars();
        }
        popMatrix();
        //draw planets
        pushMatrix();
        translate(width/2,height/3);
        sun.drawPlanet();
        sun.orbit();
        popMatrix();
        fill(255);
        textAlign(CENTER,BOTTOM);
        textSize(getTextSizeChart(width*(1.0f/4.0f),height*.2f,this.title.length()));
        text(this.choose, width*.5f, height*.75f);
        textSize(getTextSizeChart(width*(1.0f/3.0f),height*.2f,this.title.length()));
        text(this.title, width*.5f, height*.15f);
        popStyle();
    }

    public int getEvent(MouseEvent e) {
        int event;
        for(Widget w : screenWidgets) {
            event = w.getEvent(e);
            switch(event) {
                case toggleAudioEvent:
                    if(audio.isPlaying()) audio.pause();
                    else audio.play();
                    return toggleAudioEvent;
                case exitEvent:
                    exit();
                    return exitEvent;
            }
        }
        return super.getEvent(e);
    }
     public void resize()
   {
       super.resize();
       //sun.resize();
   }
}
//Class created by B.Pusch
//Class for storing  keys with values (used by graphs)
public class Mapping
{
    int value;
    String key;

    public Mapping(String key)
    {
        this.value = 1; this.key = key;
    }
    public Mapping(String key, int value)
    {
        this.key = key; this.value = value;
    }

    public int getValue()
    {
        return value;
    }

    public String getKey()
    {
        return key;
    }

    public void increment()
    {
        this.value += 1;
    }

    public int compareTo(Object obj)
    {
        if(obj instanceof Mapping)
        {
            Mapping mapping = (Mapping) obj;
            return Integer.compare(this.value,mapping.getValue());
        }
        return -1;   
    }
    public int compareToKeys(Object obj)
    {
        if(obj instanceof Mapping)
        {
            Mapping mapping = (Mapping) obj;
            return this.key.compareTo(mapping.getKey());
        }
        return -1;   
    }

    public boolean equals(Object obj)
    {
        if(obj instanceof Mapping)
        {
            Mapping mapping = (Mapping) obj;
            return key.equals(mapping.getKey());
        }
        return false; 
    }
}
//Class created by B. Pusch
//sets up orbits used in the globe screen
public class Orbit
{
    public static final float radiusOfEarth = 6378;
    private static final int strokeWeight = 1;
    private static final int selectedStrokeWeight = 4;
    boolean selected;
    String satcatID;
    PShape orbit;
    float eccentricity, adjusted_apogee, adjusted_perigee, a,b,c, xShift, yShift, inclination, currentEarthRadius, raan;

    public Orbit(String id, float ecc, float apogee, float perigee, float inclination, float raan, float xShift, float yShift, float currentEarthRadius)
    {
        this.satcatID = id; this.eccentricity = ecc; this.xShift = xShift;this.yShift=yShift;this.inclination=inclination;
        this.currentEarthRadius = currentEarthRadius; this.raan = raan;
        this.adjusted_apogee = (apogee+radiusOfEarth)/radiusOfEarth*this.currentEarthRadius;
        this.adjusted_perigee = (perigee+radiusOfEarth)/radiusOfEarth*this.currentEarthRadius;
        this.a = (adjusted_apogee+adjusted_perigee)/2;
        this.c = eccentricity*this.a;
        this.b = (float)Math.sqrt(a*a-c*c);
        this.selected = false;
        createOrbit();
    }

    public void draw()
    {
        pushStyle();
        pushMatrix();
        translate(this.xShift,this.yShift,0);
        if(selected) 
        {
            this.orbit.setStroke(color(200,0,0));
            this.orbit.setStrokeWeight(selectedStrokeWeight);
        }
        else
        {
            this.orbit.setStroke(color(100,100,100));
            this.orbit.setStrokeWeight(strokeWeight);
        }
        rotateY(TWO_PI/360*this.raan);
        rotateX(PI/2 + TWO_PI / 360 * this.inclination);
        translate(-this.c,0,0);    
        shape(this.orbit);
        popStyle();
        popMatrix(); 
    }

    public float getApogee()
    {
        return adjusted_apogee;
    }

    public String getID()
    {
        return this.satcatID;
    }

     public void createOrbit()
    {
        this.orbit = createShape();
        this.orbit.beginShape();
        this.orbit.noFill();
        this.orbit.strokeWeight(strokeWeight);
        for(int i = 0;i<=62;i++)
        {
            this.orbit.curveVertex(this.a*cos(TWO_PI/60*i),this.b*sin(TWO_PI/60*i),0);
        }
        this.orbit.endShape();
        this.orbit.setStroke(true);
    }

    public void setSelected(boolean s)
    {
        this.selected = s;
    }

    public void resize(float xShift, float yShift)
    {   
        this.xShift = xShift; this.yShift = yShift;
    }

    public int compareTo(Object obj)
    {
        if(obj instanceof Orbit)
        {
            Orbit orbit = (Orbit)obj;
            return Integer.compare(Integer.parseInt(this.satcatID),Integer.parseInt(orbit.getID()));
        }
        return -1;
    }

    public boolean equals(Object obj)
    {
        if(obj instanceof Orbit)
        {
            Orbit orbit = (Orbit) obj;
            return this.satcatID.equals(orbit.getID());
        }
        return false; 
    }
}
//Class created by B. Pusch
//function
public class OrbitMenu extends Widget
{
    ArrayList<OrbitMenuEntry> entries;
    ButtonWidget pageUp, pageDown;
    private static final int pageUpEvent = 11;
    private static final int pageDownEvent = 12;
    float fEntryHeight, entryHeight;
    private static final int numEntries = 15;
    float buttonHeight;
    ArrayList<String[]> data;
    int index, currentEntryEvent;
    boolean getEntryEvent;

    public OrbitMenu(float fx, float fy, float fwidth, float fheight, int event)
    {
        super(fx,fy,fwidth,fheight,event);
        this.data = null;
        this.buttonHeight = fheight/20;
        this.fEntryHeight = (fheight-buttonHeight)/numEntries;
        this.index = 0;
        this.currentEntryEvent = 0;
        boolean getEntryEvent = false;
        this.pageUp = new ButtonWidget(fx,fy+fheight-buttonHeight,fwidth/2,buttonHeight,"Page Up",pageUpEvent);
        this.pageDown = new ButtonWidget(fx+fwidth/2,fy+fheight-buttonHeight,fwidth/2,buttonHeight,"Page Down",pageDownEvent);
        this.entries = new ArrayList<OrbitMenuEntry>();
        for(int i =0;i<numEntries;i++)
        {
            this.entries.add(new OrbitMenuEntry(fx,fy+fEntryHeight*i,fwidth,fEntryHeight,20+i,"","0"));
        }
    }

     public void draw()
    {
        pushStyle();
        stroke(0);
        fill(255);
        rect(x,y,wWidth,wHeight);
        pageUp.draw();
        pageDown.draw();
        for(OrbitMenuEntry o: entries)
        {
            o.draw();
        }
        popStyle();
    }

     public int getEvent(MouseEvent e)
    {
        if(pageUp.getEvent(e) == pageUpEvent)
        {
            this.index = Math.max(0,index-1);
            setData();
            return this.event;
        }
        if(pageDown.getEvent(e) == pageDownEvent)
        {
            this.index = (index+1)*numEntries >= this.data.size()?index:index+1;
            setData();
            return this.event;
        }
        int event;
        for(OrbitMenuEntry ent:entries)
        {
            event = ent.getEvent(e);
            //System.out.println(event);
            if(event != NULL_EVENT)
            {
                this.currentEntryEvent = event;
                this.getEntryEvent = true;
                return this.event;
            }
                
        }
        return NULL_EVENT;
    }

    public boolean isGetID()
    {
        boolean isGetID = this.getEntryEvent;
        this.getEntryEvent = false;
        return isGetID;
    }

    public String getID()
    {
        return entries.get(this.currentEntryEvent-20).getID();
    }

     public void resize()
    {
        super.resize();
        if(pageDown != null)
            pageDown.resize();
        if(pageUp != null)
            pageUp.resize();   
        if(entries != null) 
            for(OrbitMenuEntry e:entries)
                e.resize();
    }

     public void setData()
    {
        int dataIndex;
        String label;
        for(int i =0;i<numEntries;i++)
        {
            dataIndex = index*numEntries + i;
            if(dataIndex < data.size())
            {
                label = this.data.get(dataIndex)[3] +    " | " + this.data.get(dataIndex)[4];
                this.entries.get(i).reset(this.data.get(dataIndex)[1],label);
            }
            else this.entries.get(i).resetNull();
        }
    }

     public void addData(ArrayList<String[]> data)
    {       
        this.data = data;
        setData();
    }

    public void resetIndex()
    {
        this.index = 0;
        setData();
    }
}
//Class created by B. Pusch
//function
public class OrbitMenuEntry extends Widget
{
    boolean selected;
    String label;
    int backgroundColor, textColor, selectedColor;
    String id; 

    public OrbitMenuEntry(float fx, float fy, float fwidth, float fheight, int event, String label,String id)
    {
        super(fx,fy,fwidth,fheight,event);
        this.label = label; this.id = id;
        this.backgroundColor = color(255); this.textColor = color(0);
        this.selectedColor = color(200);
        this.selected = false;
    }

     public void draw()
    {
        pushStyle();
        rectMode(CORNER);
        if(this.selected) fill(this.selectedColor);
        else fill(this.backgroundColor);
        strokeWeight(2);
        stroke(0);
        rect(this.x,this.y,this.wWidth,this.wHeight);
        textSize(getTextSize(this.wWidth, this.wHeight, this.label.length()));
        fill(this.textColor);
        text(this.label, this.x,this.y,this.wWidth,this.wHeight);
        popStyle();
    }

     public int getEvent(MouseEvent e)
    { 
        if( (mouseX >= this.x && mouseX < this.x+this.wWidth)
            &&
            (mouseY >= this.y && mouseY < this.y+this.wHeight))
        {
            this.selected = true;
            if (e.getAction() == MouseEvent.RELEASE)
            {
                return this.event;
            }
        }
        else{
            this.selected = false;
        }
        return NULL_EVENT;
    }

    public String getID()
    {
        return this.id;
    }

    public void reset(String id, String label)
    {
        this.id = id; this.label = label;
    }

    public void resetNull()
    {
        this.id = ""; this.label = "";
    }
}
//Class created by L. Chow 
//Planet objects for homescreen
public class Planet
{
  private float radius, angle, distance, orbitSpeed;
  private PVector vector;
  private PShape globe;
  private Planet[] planets;
  private PImage textures[];

  Planet(float r, float d, float o, PImage img)
  {
    this.vector = PVector.random3D();
    this.radius = r;
    this.distance = d;
    vector.mult(distance);
    this.angle = random(TWO_PI);
    this.orbitSpeed = o;
    noFill();
    noStroke();
    this.globe = createShape(SPHERE, radius);
    globe.setTexture(img);
    setTextures();
  }

  // function to add multiple plants to circle around the sun
  public void addPlanets(int total)
  {
    planets = new Planet[total];
    for (int i = 0; i < planets.length; i++)
    {
      planets[i]= new Planet (radius*0.5f, random(radius*2,radius*3), random(-0.05f, 0.05f), textures[i]);
    }
  }

  // function to make planets move around the sun
  public void orbit() 
  {
    pushMatrix();
    angle = angle + orbitSpeed;
    if (planets !=null)
      for (int i = 0; i < planets.length; i++)
      {
        planets[i].orbit();
      }
    popMatrix();
  }

  // function to draw planets
  public void drawPlanet()
  {
    pushMatrix();
    noStroke();
    lights();
    fill(255);
    PVector spin = vector.cross(new PVector(1,0,1));
    rotate(angle, spin.x,spin.y,spin.z);
    translate(vector.x,vector.y,vector.z);
    shape(this.globe);
    if (planets !=null)
      for (int i = 0; i < planets.length; i++)
      {
        planets[i].drawPlanet();
      }
    popMatrix();
  }

  // function to set textures for planets
  private void setTextures()
  {
    this.textures = new PImage[8];
    this.textures[0] = mercuryIm;
    this.textures[1] = jupiterIm;
    this.textures[2] = earthIm;
    this.textures[3] = marsIm;
    this.textures[4] = neptuneIm;
    this.textures[5] = saturnIm;
    this.textures[6] = uranusIm;
    this.textures[7] = venusIm;
  }
}
//Class created by B. Pusch
//Object for a pie chart
public class PieChart extends Graph
{
    private ArrayList<Mapping> data;
    private ArrayList<Mapping> colors;

    public PieChart(float fx, float fy, float fwidth, float fheight,String title, ArrayList<Mapping> data)
    { 
        super(fx,fy,fwidth,fheight,title);
        this.data = data;
        this.colors = new ArrayList<Mapping>();
        createColors();
    }

    public void draw()
    { 
        pushStyle();
        float offset = .15f;
        fill(0);
        noStroke();
        rect(x,y,gWidth,gHeight);
        drawPie(offset);
        fill(255);
        textSize(getTextSizeChart(gWidth,offset*height,this.title.length()));
        textAlign(CENTER,TOP);
        text(this.title,this.gWidth/2+this.x,this.y+40);
        popStyle();
    }

    private void drawPie(float offset)
    {
        pushStyle();
        float totalValue = 0;
        for(Mapping entry: this.data)
            totalValue += entry.getValue();
        float centerX = this.gWidth/2+this.x;
        float centerY = this.gHeight/2+this.y;
        float diameter = Math.min(this.gWidth*(1-2*offset),this.gHeight*(1-2*offset));
        float currentAngle = 0;
        int count =0;
        for(Mapping entry: this.data)
        {
            
            if(count<9)
            {    
                stroke(this.colors.get(Collections.binarySearch(this.colors,entry,new MappingKeyComparator())).getValue());
                fill(this.colors.get(Collections.binarySearch(this.colors,entry,new MappingKeyComparator())).getValue());
                arc(centerX,centerY,diameter,diameter,currentAngle, currentAngle+ (((float)entry.getValue())/totalValue)*2*PI,PIE);
            }
            else
            {
                fill(color(100,100,150));
                arc(centerX,centerY,diameter,diameter,currentAngle, 2*PI,PIE);
                break;
            }
            count++;
            currentAngle += (entry.getValue()/totalValue)*2*PI;
        }
        popStyle();
    }


    public void setGraph(ArrayList<Mapping> data)
    {
        this.data = data;
        Collections.sort(this.data,  new MappingComparator());
        Collections.reverse(this.data);
    }

    private void createColors()
    {
        Random random = new Random();
        ArrayList<String> countriesUsed = new ArrayList<String>();
        for(TableRow r: gcat.rows())
        {
            String temp = r.getString("State");
            if(!countriesUsed.contains(temp))
            {
                countriesUsed.add(temp);
                int colorParameter1 = random.nextInt(100)+50;
                int colorParameter2 = random.nextInt(colorParameter1/2+1);
                try{
                    this.colors.add(new Mapping(orgs.findRow(temp,"StateCode").getString("ShortEName"),color(0,colorParameter2,colorParameter1)));
                }
                catch(Exception e) {continue;}
                
            }   
        }
        Collections.sort(this.colors, new MappingKeyComparator());
    }
    public ArrayList<Mapping> getColors()
    {
        return this.colors;
    }
    
}












//Class created by L. Chow
//Superclass for the screens that will be used
class Screen
{
    ArrayList<Widget> screenWidgets;
    ArrayList<Graph> screenGraphs;
    int screenColour;
    
   public Screen()
   {
    screenWidgets = new ArrayList<Widget>();
    screenGraphs = new ArrayList<Graph>();
   }

   //function to draw widgets and graphs on the screen
    public void draw()
   {
    for(Widget w: screenWidgets)
        w.draw();
    for(Graph g: screenGraphs)
        g.draw();
   }

    //function to get mouse event
    public int getEvent(MouseEvent e)
   {
       int event;
       for(Widget w: screenWidgets)
       {
           event = w.getEvent(e);
           if(event != NULL_EVENT) return event;
       }
       return NULL_EVENT;
   }

   //function to get key event 
    public int getEvent(KeyEvent e)
   {
       int event;
       for(Widget w: screenWidgets)
       {
           event = w.getEvent(e);
           if(event != NULL_EVENT) return event;
       }
       return NULL_EVENT;
   }
   
   //function to resize the graphs and widgets
    public void resize()
   {
       for(Graph g: screenGraphs)
            g.resize();
       for(Widget w: screenWidgets)
            w.resize();
   }
}
//Class created by B. Pusch
//Slider object used by screens
//Subclass of widget class
public class Slider extends Widget
{
    int sliderColor,tickColor;
    float xTick, yTick, ftickWidth;
    float fxTick, fyTick;

    public Slider(float fx, float fy, float fwidth, float fheight,int event)
    {
        super(fx,fy,fwidth,fheight,event);
        this.xTick = x; this.yTick = y; this.ftickWidth = .03f;
        this.fxTick = this.xTick/width; this.fyTick = this.yTick/height;
        sliderColor = color(100);
        this.tickColor = color(100);
    }

    public void draw()
    {
        pushStyle();
        stroke(sliderColor);
        strokeWeight(.4f*wHeight);
        line(x,y,x+wWidth, y);
        noStroke();
        fill(sliderColor);
        circle(x,y,wHeight*.4f);
        circle(x+wWidth,y,wHeight*.4f);
        rectMode(CENTER);
        fill(tickColor);
        noStroke();
        rect(xTick, yTick, ftickWidth*width, wHeight,wHeight*.2f);
        popStyle();
    }

    public float getFractionOfSlider()
    {
        return (this.xTick-this.x)/(this.wWidth);
    }

     public int getEvent(MouseEvent e)
    {
        if(e.getAction() == MouseEvent.DRAG)
        {
            if( (mouseX >= this.xTick-this.ftickWidth*width/2 && mouseX < this.xTick+this.ftickWidth*width/2)
            &&
            mouseY >= this.yTick - this.wHeight/2 && mouseY < this.yTick+this.wHeight/2)
            {
                this.xTick = mouseX > this.x+ this.wWidth?this.x+ this.wWidth:mouseX < this.x?this.x:mouseX;
                this.fxTick = xTick/width;
                return this.event;
            }
        }
        return NULL_EVENT;
    }

     public void resize()
    {
        super.resize();
        xTick = fxTick*width;
        yTick = fyTick*height;
    }
}
//Class created by L Chow
//Star objects for background of homescreen
public class Star 
{
  private float x, y, z;

  Star()
  {
    x = random(-width, width);
    y = random(-height, height);
    z = random(width);
  }

  //function to move stars
  public void update() {
    z = z - 5;
    if (z < 1) {
      z = width;
      x = random(-width, width);
      y = random(-height, height);
    }
  }

  //function to draw stars in random places on the screen
  public void drawStars() {
    fill(255);
    noStroke();
    ellipse(map(x/z, 0, 1, 0, width), map(y/z, 0, 1, 0, height),  map (z, 0, width, 16, 0),  map (z, 0, width, 16, 0));
  }
}
//Class created by G. Mullen
// modified by B. Pusch to add functionality
//Object of text box
//Subclass of widget class
public class TextBox extends Widget{
    private final int RECT_RADII = 8;
    String input;
    boolean selected;
    String type;
    float textSize;
    String inputDisplayed;

    public TextBox(float fx, float fy, float fwidth, float fheight, int event, String type) 
    {
        super(fx, fy, fwidth, fheight, event);
        this.input = "";
        selected = false;
        this.type = type;
        this.textSize = wHeight*.7f;
        this.inputDisplayed = "";
    }

    public void draw() 
    {
        pushStyle();
        stroke(0);
        fill(255);
        rect(x, y, wWidth, wHeight, RECT_RADII);
        textSize(this.textSize);
        textAlign(LEFT,CENTER);
        fill(0);
        text(this.inputDisplayed, this.x, this.y+wHeight/2);
        popStyle();
    }

    public void updateText(char x) 
    {
        this.input += x;
        textSize(this.textSize);
        if(textWidth(this.input) > wWidth)
        {  
            inputDisplayed += x;
            for(int i = 1; textWidth(this.inputDisplayed)>wWidth;i++)
                this.inputDisplayed = this.inputDisplayed.substring(i,this.inputDisplayed.length());
        }
        else
            inputDisplayed = this.input;
    }

    // backspace key
    public void rmText() 
    {
        textSize(this.textSize);
        if(input.length()>0)
            input = input.substring(0, input.length() - 1);
        if(textWidth(this.input) > wWidth)
        {
            inputDisplayed = this.input.substring(this.input.length()-this.inputDisplayed.length(),this.input.length());
            for(int i =1; textWidth(inputDisplayed) > wWidth;i++)
                inputDisplayed = this.input.substring(i,this.input.length());
        }
        else
            inputDisplayed = this.input;
    }

    public int getEvent(MouseEvent e) 
    {
        if(e.getAction() == MouseEvent.RELEASE)
        {
            if (mouseX >= x && mouseX <= x + wWidth && mouseY >= y && mouseY <= y+wHeight) 
            {
                selected = true;
                return event;
            }
            else selected = false;
        }  
        return NULL_EVENT;
    }

    // get keypressed event
    public int getEvent(KeyEvent e) 
    {
        if (keyPressed) 
        {
            if(this.selected)
            {
                if(this.type.equalsIgnoreCase("Numbers") && (Character.isDigit(key) || (key == '.' && this.input.indexOf('.') == -1) || (this.input.length() == 0 && key ==  '-')))
                    this.updateText(key);
                else if(this.type.equalsIgnoreCase("Alphanumeric") && (Character.isDigit(key) || Character.isLetter(key) || key == ':' || key == '-' || key == '>' || key == '.'||key==';'))
                    this.updateText(key);
                else if(keyCode == BACKSPACE)
                    this.rmText();
                return this.event;
               }
            return NULL_EVENT;
           }        
        return NULL_EVENT;
    }

    public String getString() 
    {
        return this.input;
    }

     public void resize()
    {
        super.resize();
        this.textSize = this.wHeight*.7f;
    }
}
//Class made by L. Chow 
//Screen for dot plot query
//Subclass of screen class
public class TimeScreen extends Screen
{ 
    private float fHeaderHeight, fVisualizationDivider, headerHeight, visualizationDivider;
    private String title, xLabel, yLabel, switchEvent, switchCountry, country;
    private ArrayList<Float> data;
    private ArrayList<Integer> year;
    private static final int massButtonEvent = 11;
    private static final int totalMassButtonEvent = 12;
    private static final int lengthButtonEvent = 13;
    private static final int spanButtonEvent = 14;
    private static final int suButtonEvent = 15;
    private static final int ruButtonEvent = 16;
    private static final int cnButtonEvent = 17;
    private static final int usButtonEvent = 18;
    
    public TimeScreen() 
    {
        super();
        this.screenColour = color(0);
        this.fHeaderHeight = .05f;
        this.fVisualizationDivider = .32f;
        this.headerHeight = height*fHeaderHeight;
        this.visualizationDivider = height*fVisualizationDivider;
        this.country = "the Soviet Union";
        this.switchEvent = "Mass";
        this.switchCountry = "SU";
        this.xLabel = "Time (years)";
        this.yLabel = this.switchEvent+" (KG)";
        this.title = this.switchEvent+" vs Time of Objects in "+this.country;
        //arraylist for y axis data
        this.data = new ArrayList<Float>();
        //arraylist for x axis data
        this.year = new ArrayList<Integer>();
        getValues();
        //draw widgets on screen
        screenWidgets.add(new ButtonWidget(.01f,.01f,(fHeaderHeight-.01f)*2, fHeaderHeight-.02f,"Return",GRAPH_SCREEN));
        screenWidgets.add(new ButtonWidget(.15f, .8f, .12f, .07f, "Mass",massButtonEvent,20));
        screenWidgets.add(new ButtonWidget(.3f, .8f, .12f, .07f, "Total Mass",totalMassButtonEvent,20));
        screenWidgets.add(new ButtonWidget(.15f, .9f, .12f, .07f, "Length",lengthButtonEvent,20));
        screenWidgets.add(new ButtonWidget(.3f, .9f, .12f, .07f, "Span",spanButtonEvent,20));
        screenWidgets.add(new ButtonWidget(.625f, .8f, .12f, .07f, "Soviet Union",suButtonEvent,20));
        screenWidgets.add(new ButtonWidget(.775f, .8f, .12f, .07f, "Russia",ruButtonEvent,20));
        screenWidgets.add(new ButtonWidget(.625f, .9f, .12f, .07f, "China",cnButtonEvent,20));
        screenWidgets.add(new ButtonWidget(.775f, .9f, .12f, .07f, "United States",usButtonEvent,20));
        //draw dot plot graph
        screenGraphs.add(new DotPlot(0.0f,fHeaderHeight,1, 0.75f, this.title, this.data, this.year,this.xLabel, this.yLabel));
    }

    public void draw()
    {
        pushStyle();
        background(this.screenColour);
        //draw header
        fill(color(32,33,36));
        rect(0,0,width,headerHeight);
        //draw divider
        fill(50);
        strokeWeight(2);
        stroke(200);
        rect(width*0.05f,height*.785f, .9f*width, .2f*height,8);
        fill(255);
        textSize(25*height/800);
        text("Filter : ",width*.1f, .9f*height);
        text("Country : ",width*.55f, .9f*height);
        popStyle();
        super.draw();
    }
 
    //function to get, change variables and return event to update graph
    public int getEvent(MouseEvent e)
    {
        int event;
        for (Widget w: screenWidgets)
        {
            event = w.getEvent(e);
            switch(event)
            {
                //mass widget pressed, update to new graph and title with mass variable and current country
                case massButtonEvent:
                    this.switchEvent = "Mass";
                    getValues();
                    this.title = this.switchEvent+" vs Time of Objects in "+this.country;
                    this.yLabel = this.switchEvent+" (KG)";
                    ((DotPlot)screenGraphs.get(0)).setGraph(this.data,this.year,this.title,this.xLabel,this.yLabel); 
                    return event;
                //total mass widget pressed, update to new graph and title with total mass variable and current country
                case totalMassButtonEvent:
                    this.switchEvent = "TotMass";
                    getValues();
                    this.yLabel =  "Total Mass (KG)";
                    this.title = "Total Mass vs Time of Objects in "+this.country;
                    ((DotPlot)screenGraphs.get(0)).setGraph(this.data,this.year,this.title,this.xLabel,this.yLabel); 
                    return event;
                //length widget pressed, update to new graph and title with length variable and current country
                case lengthButtonEvent:
                    this.switchEvent = "Length";
                    getValues();
                    this.title = this.switchEvent+" vs Time of Objects in "+this.country;
                    this.yLabel = this.switchEvent+" (M)";
                    ((DotPlot)screenGraphs.get(0)).setGraph(this.data,this.year,this.title,this.xLabel,this.yLabel); 
                    return event;
                //span widget pressed, update to new graph and title with span variable and current country
                case spanButtonEvent:
                    this.switchEvent = "Span";
                    getValues();
                    this.title = this.switchEvent+" vs Time of Objects in "+this.country;
                    this.yLabel = this.switchEvent+" (M)";
                    ((DotPlot)screenGraphs.get(0)).setGraph(this.data,this.year,this.title,this.xLabel,this.yLabel); 
                    return event;
                //SU widget pressed, update to new graph and title with Soviet Union country and current variable
                case suButtonEvent:
                    this.switchCountry = "SU";
                    this.country = "the Soviet Union";
                    getValues();
                    if (this.switchEvent.equals("TotMass"))
                        this.title = "Total Mass vs Time of Objects in "+this.country;
                    else 
                        this.title = this.switchEvent+" vs Time of Objects in "+this.country;
                    ((DotPlot)screenGraphs.get(0)).setGraph(this.data,this.year,this.title,this.xLabel,this.yLabel); 
                    return event;
                //Russia widget pressed, update to new graph and title with Russia country and current variable
                case ruButtonEvent:
                    this.switchCountry = "RU";
                    this.country = "Russia";
                    getValues();
                    if (this.switchEvent.equals("TotMass"))
                        this.title = "Total Mass vs Time of Objects in "+this.country;
                    else 
                        this.title = this.switchEvent+" vs Time of Objects in "+this.country;
                    ((DotPlot)screenGraphs.get(0)).setGraph(this.data,this.year,this.title,this.xLabel,this.yLabel); 
                    return event;
                //China widget pressed, update to new graph and title with China country and current variable
                case cnButtonEvent:
                    this.switchCountry = "CN";
                    this.country = "China";
                    getValues();
                   if (this.switchEvent.equals("TotMass"))
                        this.title = "Total Mass vs Time of Objects in "+this.country;
                    else 
                        this.title = this.switchEvent+" vs Time of Objects in "+this.country;
                    ((DotPlot)screenGraphs.get(0)).setGraph(this.data,this.year,this.title,this.xLabel,this.yLabel); 
                    return event;
                //US widget pressed, update to new graph and title with United states country and current variable
                case usButtonEvent:
                    this.switchCountry = "US";
                    this.country = "the United States";
                    getValues();
                    if (this.switchEvent.equals("TotMass"))
                        this.title = "Total Mass vs Time of Objects in "+this.country;
                    else 
                        this.title = this.switchEvent+" vs Time of Objects in "+this.country;
                    ((DotPlot)screenGraphs.get(0)).setGraph(this.data,this.year,this.title,this.xLabel,this.yLabel); 
                    return event;
                //return to graph screen
                case GRAPH_SCREEN:
                    return event;
            }
        }
        return NULL_EVENT;
    }

    //function to get values with the current variable and country
    private void getValues()
    {
        boolean hasData = true;
        for (int row = 0; row<=gcat.getRowCount(); row++)
        {
            try
            {
                String state = gcat.getString(row, "State");
                if (state.equals(this.switchCountry))
                {
                    if (hasData && this.data != null)
                    {
                        this.data.clear();
                        this.year.clear();
                    }
                    hasData = false;
                    data.add(gcat.getFloat(row, this.switchEvent));
                    year.add(Integer.parseInt(gcat.getString(row,"LDate").substring(0,4)));
                }
            }
            catch(Exception e) {continue;}
        }
    }

    //function to resize screen
     public void resize()
    {
        super.resize();
        this.headerHeight = fHeaderHeight*height;
    }
}
//Class created by B. Pusch
//Superclass for widget objects
public class Widget
{
    float fx, fy, fwidth, fheight; 
    float x,y,wWidth,wHeight;
    int event;
    
    Widget(float fx, float fy, float fwidth, float fheight, int event)
    {
        this.fx = fx; this.fy = fy; this.fwidth = fwidth; this.fheight = fheight;
        this.event = event;
        this.resize();
    }

     public void draw()
    {
    } 

     public int getEvent(MouseEvent e)
    {
        return NULL_EVENT;
    }

     public int getEvent(KeyEvent e)
    {
        return NULL_EVENT;
    }
    
     public void resize()
    {
        this.wWidth = width * fwidth;
        this.wHeight =  height * fheight;
        this.x = width * fx;
        this.y = height * fy;
    }
}
//File created by B. Pusch
//Methods needed throughout the project

//given a rectangle, this returns the pixel size of each letter so that the text fits into the rectangle for globe
public float getTextSize(float width, float height, int length)
{
    return height*.7f;  //for globe
}

//given a rectangle, this returns the pixel size of each letter so that the text fits into the rectangle for graphs
public float getTextSizeChart(float width, float height, int length)
{
    return Math.min(height*.8f,(width)/(float)length*1.2f); 
}

public class MappingComparator implements Comparator<Mapping> 
{
    @Override
    public int compare(Mapping m1, Mapping m2) 
    {
        return m1.compareTo(m2);
    }
}

public class MappingKeyComparator implements Comparator<Mapping> 
{
    @Override
    public int compare(Mapping m1, Mapping m2) 
    {
        return m1.compareToKeys(m2);
    }
}

public class OrbitComparator implements Comparator<Orbit> 
{
    @Override
    public int compare(Orbit o1, Orbit o2) {
        return o1.compareTo(o2);
    }
}

public class GlobeDataComparator implements Comparator<String[]> 
{
    @Override
    public int compare(String s1[], String s2[]) {
        return s1[1].compareTo(s2[1]);
    }
}


  public void settings() { size(1000, 800, P3D);
smooth(); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Project" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
